# Sorcery Grids 2.0.0β

**A highly configurable, fun, responsive grid system!**

* Fully responsive
* Mobile first option
* Infinitely nestable
* Reversible / re-orderable grids
* With / without gutters
* Focus on clean, quick, readable code
* Endless possible combinations - literally!
* Generate any ratios you desire, and only generate ones you need
* Can use Sass @extend-friendly classes to keep your HTML simple
* No need for `.clear` or `.last` classes
* Version 2 is now even more configurable!

It can seem like a pretty daunting grid system simply due to its internal code; however the goal is to produce clean, reusable, friendly classes, and only those you need.

## Browser Support

Sorcery Grids are compatible with all modern desktop browsers and modern mobile browsers which have support for `display: inline-block;` and CSS *rem* units. Out of the box, the minimum IE supported version is IE9, however it is absolutely possible to bake in IE7/8 support, with use of appropriate polyfills as needed.

Note that at the moment, Android Browser 4.3.x and below have issues with the use of whitespace and REM units. This is resolved as of Android 4.4. There are some possible workarounds if you aren't able to eliminate whitespace in your HTML:

1. Remove white space between your grid tags. This is often quite error-prone, especially when being generated by a CMS.
2. Forego some of the niceness of inline blocks (vertical alignment, centring) and use floats. This is set with the configuration option `$use-logic`.
3. Enable some imprecision (very minor, a few px at most) into the grids generated with the option `$use-imprecision-hack` set to `true`. Desktop browsers such as Chrome, Safari and Internet Explorer account for it *mostly* - mobile browsers tend to be most affected in their output. However, this imprecision does negate the need for messing with whitespace.
4. If you wanted to use JavaScript to sniff for Android devices, you could add in a negative word-spacing (-.43rem on grid container, normal on grid item) and letter-spacing (-.31rem on grid container, normal on grid item) hack. You'd need to use JavaScript as this hack now breaks in Chrome as of version 25 and so cannot reliably be used with desktop browsers. There are also issues with this and some custom fonts.

## Demo

A demo file is included. Further demos are being worked on, as the beta version progresses.

## Setup

If you can use Sass, you can use Sorcery Grids. There's only one file to include. For flexibility, it's recommended you override the configuration in your own Sass files. You can see the demo files for an example of this.

## Usage

Sorcery Grids is simple to implement and its classes are human-readable. You can also configure it to your preferences. By default, it uses classes of the form `.grid-1-4` for a one quarter width grid. However you can configure most of the naming to your liking. There are options for using words instead of numbers, changing the namespacing, and whether you prefer breakpoint names as a prefix or suffix.

Setting up the breakpoints is probably the most complex part, so check out the demos to see how they work. Sorcery Grids has a logic core that lets you dynamically generate any ratio sets you want. Feel like sevenths? Let it make them for you. Want to use seventeenths for some reason? Nothing stopping you. Sorcery Grids will only generate those ratio sets you request.

I find that when developing, using static classes straight in HTML is a fast way to prototype, but I also later might want to consolidate things down using silent classes. Whether static or silent, the tradeoff is either complexity in HTML, or complexity in CSS. However when you want to swap, if it's either static OR silent, you have to change all your `.names` to `%names`, a tedious process. Sorcery Grids lets you get around this by developing initially with static in HTML, setting up silent `@extend` classes as you go, by having both static and silent turned on. Then later you can just turn off static generation to keep your resulting HTML code clean.

There are also some differences in how nesting is approached, as well as guttering.

### Patterns

Sorcery Grids' classes are based on [a modified BEM
syntax](http://csswizardry.com/2013/01/mindbemding-getting-your-head-round-bem-syntax/) with a slight bending of the rules when using numeric fractions, to keep name complexity to a minimum.

* `.grid` is a **B**lock
* `.grid__item` is an **E**lement of the block
* `.grid--rev` is a **M**odifier of the block. `.grid__item--rev` would be a modifier of the element

Classes include your breakpoint namespaces (e.g. `.s--grid-1-2`, `.m--grid-2-3` and so on); your push and pull classes (`.push--grid-1-3`, `.pull--m--grid-1-4` and so on); your regular classes (`.grid-1-10`, `.grid-3-4` etc).

Knowing these patterns will allow you to create hundreds of different combinations. A few examples:

    // Sets an item to be one half across all breakpoints.
    .grid-1-2 {}

    // Pushes an item one third of the way to the right across all breakpoints.
    .push--grid-1-3 {}

    // Sets an item to be ten twelfths wide only at the lap breakpoint.
    .m--grid-10-12 {}

    // Pulls an item one half of the way to the left only at the palm breakpoint.
    .pull--m--grid-1-2 {}

Code styling can be a controversial topic, but I try to "blend in" with each language I write. That said, I like tabs for indentation, and spaces for alignment. You may have different preferences. Feel free to change things for yourself if you prefer.

### Classes in markup

If you are using traditional classes then an example, basic usage might look like this:

    <div class="grid">

        <div class="grid__item  m--grid-1-2  l--grid-1-3">
            ...
        </div>

        <div class="grid__item  m--grid-1-2  l--grid-2-3">
            ...
        </div>

    </div>

It’s as simple as that!

---

**No need for empty HTML comments! (With a few caveats)**

I did feel this was an unfortunate shortcoming of the CSS Wizardry Grids, stemming from the way browsers treat whitespace when using `display: inline-block;`, which is not an issue when using systems that rely on floats. I really, really am not a fan of kludging HTML with empty comments or other tag position trickery to mitigate whitespace. An ideal situation is to post-process all HTML through a whitespace minifier if possible. Sometimes that isn't possible. But even with the whitespace issues, there are some amazing things you can do with inline blocks that simply cannot be achieved with floats - vertical alignment of neighbours for example. Or automatically centring a set of grid items that aren't taking up the full width. That means we need to deal with this whitespace problem *somehow*.

Sorcery Grids gets around this by using CSS *rem*, or *root em* units. By setting the font size of grid containers to 0, and then resetting grid items to 1rem, whitespace is effectively negated. No need for blank comments littering your code, and no worries about integrating with a CMS that will create code you may not have precise control over.

There are some considerations with *rem* units, so just remember that any relative styling you add to a grid item must use either a fixed unit like *px* - though that isn't recommended - or *rem* units.

The biggest challenge is Android support, as described near the top of this readme.

If you are supporting IE8, you can swap to em units and the negative letter spacing fix, and that is then fairly reliable. Add any polyfills like media query support or even *rem* unit support as needed.

---

### Sass’ silent classes

If you are using silent classes (`$use-silent-classes: true;`) then your HTML
might look like this:

    <div class="page">

        <div class="content">
            ...
        </div>

        <div class="sub-content">
            ...
        </div>

    </div>

…and your Sass, something like this:

    .page{
        @extend %grid;
    }

    .content,
    .sub-content{
        @extend %grid__item;
        @extend %m--grid-1-2;
    }

    .content{
        @extend %grid-2-3;
    }

    .sub-content{
        @extend %grid-1-3;
    }

Sass will intelligently generate and combine the definitions of just those classes which you need. Be careful though - the more silent `@extend`s you use, the larger the CSS will be. Sorcery Grids 2 attempts to mitigate this by requiring a few more helper-classes for some of the extended features. With gzipping server-side this is less of an issue, but it is one worth considering.

### Reversed grids (`.grid--rev{}`)

Sorcery has the option to reverse a set of grids; this means that the order you write your source and the order it renders are total opposites, for example:

    <div class="grid  rev">

        <div class="main-content  rev--reset  grid__item  grid-2-3">
            I appear first in the markup, but render second in the page.
        </div>

        <div class="sub-content  rev--reset  grid__item  grid-1-3">
            I appear second in the markup, but render first in the page.
        </div>

    </div>

This is handy if you want to lay out your page a certain way visually but it would be advantageous to order the source differently, for example to aid accessibility (getting a screenreader to read more important content first).

Note the use of `rev--reset` in the child classes. This was automatic Sorcery 1.0, but it caused some pretty severe code bloat if using silent classes. Sorcery 2.0 requires the use of this helper class.

### Grids and Gutters

Gutters are highly flexible in Sorcery Grids. You can have them either on or off by default, and you can optionally generate selective guttering classes. Going even further, you can choose to have gutter modifiers to create wider or thinner gutters on the same page. Check out the comments in the grid file for more information.

### Right-aligned grids (`.align--right{}`)

If enabled, keep grids in their correct order, but have them flush right instead of left:

    <div class="grid  align--right">

        <div class="grid__item  grid-1-4">
            I render first but start in the middle of the page.
        </div>

        <div class="grid__item  grid-1-4">
            I render second and appear at the very right edge of the page.
        </div>

    </div>

### Centred grids (`.align--center{}`)

If enabled, you can centrally align your grids by simply using the `.align--center` modifier:

    <div class="grid  align--center">

        <div class="grid__item  grid-1-2">
            I’m in the middle!
        </div>

    </div>

### Vertically aligned grids (`.align--[middle|bottom]{}`)

If enabled, you can vertically align your grids to each other by simply using the `.align--[middle|bottom]` modifiers:

    <div class="grid  align--middle">

        <div class="grid__item  grid-1-2">
            I’m in the middle!
        </div>

        <div class="grid__item  grid-1-2">
            I’m in the middle!
        </div>

    </div>

### Credits

Sorcery Grids was written by Mike Hopkins, and based on the amazing work done by Harry Roberts of CSS Wizardry. I greatly respect the work that he has released, as many of the core logic ideas of Sorcery Grids come straight from the CSS Wizardry Grids code.

=======
# Sorcery Grids

**A highly configurable, Sass-based, responsive grid system based on [CSS Wizardry Grids](http://csswizardry.com/csswizardry-grids/)**

* Fully responsive
* Mobile first option
* Infinitely nestable
* Reversible / re-orderable grids
* With / without gutters
* Focus on clean, quick, readable code
* Endless possible combinations - literally!
* Generate any ratios you desire, and only generate ones you need
* Can use Sass @extend-friendly classes to keep your HTML simple
* No need for `.clear` or `.last` classes

## Browser Support

Sorcery Grids are compatible with all modern desktop browsers and modern mobile browsers which have support for `display: inline-block;` and CSS *rem* units. Out of the box, the minimum IE supported version is IE9, however it is absolutely possible to bake in IE7/8 support, with use of appropriate polyfills as needed.

Note that at the moment, Android Browser 4.3.x and below have issues with the use of whitespace and REM units. This is resolved as of Android 4.4. There are some possible workarounds if you aren't able to eliminate whitespace in your HTML:

1. Minify your source code. In PHP, this can be done by capturing and parsing the output buffer at its most basic; you may wish to cache the output to prevent parsing with every page view. Other languages such as ASP have similar possibility.
2. Forego some of the niceness of inline blocks (vertical alignment, centring) and use floats. This is set with the configuration option `$use-logic`.
3. Enable some imprecision (very minor, a few px at most) into the grids generated with the option `$use-imprecision-hack` set to `true`. Desktop browsers such as Chrome, Safari and Internet Explorer account for it *mostly* - mobile browsers tend to be most affected in their output. However, this imprecision does negate the need for messing with whitespace.
4. If you wanted to use JavaScript to sniff for Android devices, you could add in a negative word-spacing (-.43rem on grid container, normal on grid item) and letter-spacing (-.31rem on grid container, normal on grid item) hack. You'd need to use JavaScript as this hack now breaks in Chrome as of version 25 and so cannot reliably be used with desktop browsers - or some custom fonts.

A future idea could be using flexbox, although it seems that the CSS Grid Layout spec may be the best future solution. However this would forego any backwards-compatibility needs. There is also the issue of differing levels of support due to the different draft specs. Browser render performance, mostly notably with the older draft specs, may be an important consideration for mobile devices. However increases in hardware and software in the next two to three years could render performance consisderations entirely negligible for the most part.

## Demo

Some demo files are included with the system. These are fairly simple for the time being, but it's anticipated they'll grow over time.

## Setup

If you can use Sass, you can use Sorcery Grids. There's only one file to include. For flexibility, it's recommended you override the configuration in your own Sass files. You can see the demo files for an example of this.

## Usage

Sorcery Grids is simple to implement and its classes are human-readable. You can also configure it to your preferences. By default, it uses classes of the form `.sg-1-4` for a one quarter width grid. However you can certainly configure it to generate more CSS Wizardry Grids-like names. If you really like CSS Wizardry Grids naming, change `$namespace` to "grid", set `$use-grid-namespace` to false and set `$use-ratio-names` to true -- that will instead generate names like `.one-quarter`. There are limits with this setup, as name classes only exist up to twelfths for the time being.

Setting up the breakpoints is probably the most complex part, so check out the demos to see how they work. Unlike CSS Wizardry Grids where the available ratios are halves, thirds, quarters, fifths, sixths, eighths, tenths and twelfths, Sorcery Grids has a logic core that lets you dynamically generate any ratio sets you want. Feel like sevenths? Let it make them for you. Want to use seventeenths for some reason? Nothing stopping you. Also unlike CSS Wizardry Grids, Sorcery Grids will only generate those ratio sets you request. Keeps things neat.

I find that when developing, using static classes straight in HTML is a fast way to prototype, but I also later might want to consolidate things down using silent classes. Whether static or silent, the tradeoff is either complexity in HTML, or complexity in CSS. However when you want to swap, if it's either static OR silent, you have to change all your `.names` to `%names`, a tedious process. Sorcery Grids lets you get around this by developing initially with static in HTML, setting up silent `@extend` classes as you go, by having both static and silent turned on. Then later you can just turn off static generation to keep your resulting HTML code clean.

An area where the grid system does differ in behaviour from CSS Wizardry Grids is in the push and pull classes. In CSS Wizardry Grids, push and pull use CSS left and right, whereas in Sorcery Grids it will use margin-left and margin-right. If you need left and right offsetting, the shift and unshift modifiers will be what you're after.

There are also some differences in how nesting is approached, as well as guttering.

### Patterns

Sorcery Grids' classes are based on [a modified BEM
syntax](http://csswizardry.com/2013/01/mindbemding-getting-your-head-round-bem-syntax/) with a slight bending of the rules when using numeric fractions, to keep name complexity to a minimum.

* `.sg` is a **B**lock
* `.sg__item` is an **E**lement
* `.sg--rev` is a **M**odifier

Classes include your breakpoint namespaces (e.g. `.palm--sg-1-2`, `.lap--sg-2-3` and so on); your push and pull classes (`.push--sg-1-3`, `.pull--lap--sg-1-4` and so on); your regular classes (`.sg-1-10`, `.sg-3-4` etc).

Knowing these patterns will allow you to create hundreds of different combinations. A few examples:

    // Sets an item to be one half across all breakpoints.
    .sg-1-2 {}

    // Pushes an item one third of the way to the right across all breakpoints.
    .push--sg-1-3 {}

    // Sets an item to be ten twelfths wide only at the lap breakpoint.
    .lap--sg-10-12 {}

    // Pulls an item one half of the way to the left only at the palm breakpoint.
    .pull--palm--sg-1-2 {}

Code styling can be a controversial topic, but I try to "blend in" with each language I write. That said, I like tabs for indentation, and spaces for alignment. Normally I like Allman-style bracing too - I find the extra space helps readability, but here I've kept things within a more CSS-like behaviour. You may have different preferences. That's fine too. Feel free to change things for yourself if you prefer.

### Classes in markup

If you are using traditional classes then an example, basic usage might look like this:

    <div class="sg">

        <div class="sg__item  sg-2-3  lap--sg-1-2  palm--sg-1">
            ...
        </div>

        <div class="sg__item  sg-1-3  lap--sg-1-2  palm--sg-1">
            ...
        </div>

    </div>

It’s as simple as that!

---

**No need for empty HTML comments! (With a few caveats)** 

I did feel this was an unfortunate shortcoming of the CSS Wizardry Grids, stemming from the way browsers treat whitespace when using `display: inline-block;`, which is not an issue when using systems that rely on floats. I really, really am not a fan of kludging HTML with empty comments or other tag position trickery to mitigate whitespace. An ideal situation is to post-process all HTML through a whitespace minifier if possible. Sometimes that isn't possible. But even with the whitespace issues, there are some amazing things you can do with inline blocks that simply cannot be achieved with floats - vertical alignment of neighbours for example. Or automatically centring a set of grid items that aren't taking up the full width. That means we need to deal with this whitespace problem *somehow*.

Sorcery Grids gets around this by using CSS *rem*, or *root em* units. By setting the font size of grid containers to 0, and then resetting grid items to 1rem, whitespace is effectively negated. No need for blank comments littering your code, and no worries about integrating with a CMS that will create code you may not have precise control over.

There are some considerations with *rem* units, so just remember that any relative styling you add to a grid item must use either a fixed unit like *px* - though that isn't recommended - or *rem* units.

The biggest challenge is Android support, as described near the top of this readme.

If you are supporting IE8, you can swap to em units and the negative letter spacing fix, and that is then fairly reliable. Add any polyfills like media query support or even *rem* unit support as needed.

---

### Sass’ silent classes

If you are using silent classes (`$use-silent-classes: true;`) then your HTML
might look like this:

    <div class="page">

        <div class="content">
            ...
        </div>

        <div class="sub-content">
            ...
        </div>

    </div>

…and your Sass, something like this:

    .page{
        @extend %sg;
    }
    
    .content,
    .sub-content{
        @extend %sg__item;
        @extend %lap--sg-1-2;
        @extend %palm--sg-1;
    }

    .content{
        @extend %sg-2-3;
    }

    .sub-content{
        @extend %sg-1-3;
    }

Sass will intelligently generate and combine the definitions of just those classes which you need. Be careful though - the more silent `@extend`s you use, the larger the CSS will be. With gzipping server-side this is less of an issue, but it is one worth considering.

### Reversed grids (`.sg--rev{}`)

Sorcery, like CSS Wizardy Grids, has the option to reverse a set of grids; this means that the order you write your source and the order it renders are total opposites, for example:

    <div class="sg  sg--rev">

        <div class="main-content  sg__item  sg-2-3">
            I appear first in the markup, but render second in the page.
        </div>

        <div class="sub-content  sg__item  sg-1-3">
            I appear second in the markup, but render first in the page.
        </div>

    </div>

This is handy if you want to lay out your page a certain way visually but it would be advantageous to order the source differently, for example to aid accessibility (getting a screenreader to read more important content first).

### Grids and Gutters

Gutters are highly flexible in Sorcery Grids. You can have them either on or off by default, and you can optionally generate selective guttering classes. Going even further, you can choose to have gutter modifiers to create wider or thinner gutters on the same page. Check out the comments in the grid file for more information.

### Right-aligned grids (`.sg--right{}`)

If enabled, keep grids in their correct order, but have them flush right instead of left:

    <div class="sg  sg--right">

        <div class="sg__item  sg-1-4">
            I render first but start in the middle of the page.
        </div>

        <div class="sg__item  sg-1-4">
            I render second and appear at the very right edge of the page.
        </div>

    </div>

### Centred grids (`.sg--center{}`)

If enabled, you can centrally align your grids by simply using the `.sg--center` modifier:

    <div class="sg  sg--center">

        <div class="sg__item  sg-1-2">
            I’m in the middle!
        </div>

    </div>

### Vertically aligned grids (`.sg--[middle|bottom]{}`)

If enabled, you can vertically align your grids to each other by simply using the `.sg--[middle|bottom]` modifiers:

    <div class="sg  sg--middle">

        <div class="sg__item  sg-1-2">
            I’m in the middle!
        </div>

        <div class="sg__item  sg-1-2">
            I’m in the middle!
        </div>

    </div>

### Credits

Sorcery Grids was written by Mike Hopkins, and based on the amazing work done by Harry Roberts of CSS Wizardry. I greatly respect the work that he has released, as many of the core logic ideas of Sorcery Grids come straight from the CSS Wizardry Grids code.

Of course, Sorcery Grids is by no means the perfect grid system. Feel free to take it and modify it, use bits from it, and learn from it. But most of all, have fun with it!